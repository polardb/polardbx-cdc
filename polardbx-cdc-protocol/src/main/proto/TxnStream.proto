syntax = "proto3";

package com.aliyun.polardbx.binlog.protocol;

option java_multiple_files = true;
option java_package = "com.aliyun.polardbx.binlog.protocol";
option optimize_for = SPEED;

service TxnService{
  rpc dump(DumpRequest) returns (stream DumpReply){}
}

message DumpRequest{
  string tso = 1;
}

message DumpReply{
  repeated TxnMessage txnMessage = 1;
}

message TxnMessage{
  MessageType   type = 1;
  TxnBegin      txnBegin = 2;
  TxnData       txnData = 3;
  TxnEnd        txnEnd = 4;
  TxnTag        txnTag = 5;
}

enum MessageType{
  /**
    Begin,Data,End未拆分，一个完整的消息体
   */
  WHOLE = 0;
  /**
    Message开始标识
   */
  BEGIN = 1;
  /**
    Message包含的数据
   */
  DATA = 2;
  /**
    Message结束标识
   */
  END = 3;
  /**
    一个独立的消息标记，当没有TxnItem需要传递时，使用该类型
   */
  TAG = 4;
}

message TxnBegin{
  oneof token_oneof{
    TxnToken        txnToken = 1;
    TxnMergedToken  txnMergedToken = 2;
  }
}

message TxnData{
  repeated TxnItem    txnItems = 1;
}

message TxnEnd{
  //暂时没有payload
}

message TxnTag{
  oneof token_oneof{
    TxnToken        txnToken = 1;
    TxnMergedToken  txnMergedToken = 2;
  }
}

message TxnToken{
  string          tso = 1;
  string          txnId = 2;
  string          partitionId = 3;
  string          originMergeSourceId = 4;
  TxnType         type = 5;
  bool            xaTxn = 6;
  /**
    标识是否为Tso事务。虽然【Tso事务】和【NoTso事务】的Token都有tso字段，
    但是【NoTso事务】的tso是根据其前序【Tso事务】的真实tso生成的虚拟tso
   */
  bool            tsoTransaction = 7;
  /**
    该事务下的所有LogEvent的个数，注意：不是某个批次的的个数
   */
  int32           txnSize = 8;
  /**
    dumper生成事务的begin头时使用
   */
  string          beginSchema = 9;
  repeated string allParties = 10;
  /**
    一些特殊的TxnToken，没有TxnItem的概念，此时通过payload字段传输数据
   */
  bytes           payload = 11;
  /**
    Tso事务专用
   */
  int64           snapshotSeq = 12;
}

message TxnMergedToken{
  string          tso = 1;
  TxnType         type = 2;
  string          beginSchema = 3;
  bytes           payload = 4;
}

message TxnItem{
  /**
    1.traceId是分布式事务内，合并多个物理分片的事件时，进行排序的依据</br>
    2.为了便于统一处理，不管是单机事务还是分布式事务都要求传入，并且要保证同一事务在同一物理分片的traceID单调递增 </br>
    3.如果物理binlog中带有traceId标识，直接使用即可；如果物理binlog中不带有traceId标识，通过"时间戳+自增序列"手动生成 </br>
  */
  string          traceId = 1;
  string          rowsQuery = 2;
  /**
    1.对应mysql的EventType
   */
  int32           eventType = 3;
  /**
    1.二进制数据
   */
  bytes           payload = 4;
}

enum TxnType{
  /**
    正常的DML
   */
  DML = 0;
  /**
    BINLOG协议描述
   */
  FORMAT_DESC = 1;
  /**
    元信息：逻辑DDL
   */
  META_DDL = 2;
  /**
    元信息：Storage发生ScaleOut or ScaleIn
   */
  META_SCALE = 3;
  /**
    元信息：逻辑DDL(PolarX私有类型的DDL)
   */
  META_DDL_PRIVATE = 4;
  /**
    元信息：心跳信息
   */
  META_HEARTBEAT = 5;
  /**
    元信息：config配置变更
   */
  META_CONFIG_ENV_CHANGE = 6;
}
